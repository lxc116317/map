package com.lxc.test;

import java.util.HashMap;

public class test1 {
	/**
	 * * A:案例演示
	 * 需求：统计字符串中每个字符出现的次数
	 * 
	 * 分析:
	 * 1,定义一个需要被统计字符的字符串
	 * 2,将字符串转换为字符数组(转换成字符数组就能够拿到每个字符)
	 * 3,定义双列集合(用hashMap，因为linkedhashMap底层是链表实现的，要保证怎么存就怎么取，TreeMap是要进行排序的,而hashMap只要往里扔就行了,效率高,默认用hashMap),存储字符串中字符(键)以及字符出现的次数(值)
	 * 4,遍历字符数组获取每一个字符,并将字符存储在双列集合中
	 * 5,存储过程中要做判断,如果集合中不包含这个键,就将该字符当作键,值为1存储,如果集合中包含这个键,就将值加1存储
	 * 6,打印双列集合获取字符出现的次数
	 */
	public static void main(String[] args) {
		//1,定义一个需要被统计字符的字符串
		String s="aaaaabbbbbaabccccccccccccccc";
		//2,将字符串转换为字符数组(转换成字符数组就能够拿到每个字符)
		char[] arr=s.toCharArray();
		//3,定义双列集合(用hashMap，因为linkedhashMap底层是链表实现的，要保证怎么存就怎么取，TreeMap是要进行排序的,而hashMap只要往里扔就行了,效率高,默认用hashMap),存储字符串中字符(键)以及字符出现的次数(值)
		HashMap<Character, Integer> hm=new HashMap<>();
		//4,遍历字符数组获取每一个字符,并将字符存储在双列集合中
		for(char c :arr) {
			//5,存储过程中要做判断,如果集合中不包含这个键,就将该字符当作键,值为1存储,如果集合中包含这个键,就将值加1存储
			/*if(!hm.containsKey(c)) {
				hm.put(c,1);						//将字符存进双列集合中
			}else {
				hm.put(c, hm.get(c)+1);				//hm.get()根据键获取值，然后再加上1
			}*/
			hm.put(c,!hm.containsKey(c)?1:hm.get(c)+1);	//三目运算符
		}
		// 6,打印双列集合获取字符出现的次数
		for(Character key:hm.keySet()) {			//hm.keySet代表所有键的集合
			System.out.println(key+"="+hm.get(key));
		}
	}

}
